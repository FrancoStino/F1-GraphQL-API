name: F1 Sync DB

on:
  workflow_dispatch:
  schedule:
    - cron: "*/30 * * * *" # At every 30th minute.

jobs:
  update-database:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "23"
      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y mariadb-client unzip curl jq pv
          yarn install
      - name: Configure Git
        run: |
          git config --global user.name "Davide Ladisa"
          git config --global user.email "info@davideladisa.it"
      - name: Get latest F1DB release
        id: get_latest_release
        run: |
          LATEST_RELEASE_URL=$(curl -s https://api.github.com/repos/f1db/f1db/releases/latest | jq -r '.assets[] | select(.name == "f1db-sql-mysql-single-inserts.zip") | .browser_download_url')
          LATEST_RELEASE_TAG=$(curl -s https://api.github.com/repos/f1db/f1db/releases/latest | jq -r '.tag_name')
          echo "download_url=$LATEST_RELEASE_URL" >> "$GITHUB_OUTPUT"
          echo "latest_tag=$LATEST_RELEASE_TAG" >> "$GITHUB_OUTPUT"
          echo "Download URL: $LATEST_RELEASE_URL"
          echo "Latest Tag: $LATEST_RELEASE_TAG"
      - name: Check if release exists in last-release.txt
        id: check_release
        run: |
          LATEST_TAG="${{ steps.get_latest_release.outputs.latest_tag }}"
          if [ ! -s "db/last-release.txt" ]; then
            echo "Last release file is empty, populating with latest release"
            echo "$LATEST_TAG" > db/last-release.txt
            echo "is_new_release=true" >> "$GITHUB_OUTPUT"
          else
            CURRENT_RELEASE=$(cat db/last-release.txt)
            echo "Current stored release: $CURRENT_RELEASE"
            echo "Latest release: $LATEST_TAG"
            if [ "$CURRENT_RELEASE" != "$LATEST_TAG" ]; then
              echo "New release detected"
              echo "is_new_release=true" >> "$GITHUB_OUTPUT"
            else
              echo "No new release detected"
              echo "is_new_release=false" >> "$GITHUB_OUTPUT"
            fi
          fi
      - name: Exit if no new release
        if: steps.check_release.outputs.is_new_release == 'false'
        run: |
          echo "No new release found. Exiting workflow."
          exit 0
      - name: Download F1DB release
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          curl -L ${{ steps.get_latest_release.outputs.download_url }} -o f1db.zip
          unzip f1db.zip
          ls -la
      - name: Apply SQL to database
        if: steps.check_release.outputs.is_new_release == 'true'
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: davideladisa.it
          DB_USER: um5i6722_f1_graphql
          DB_NAME: um5i6722_f1_graphql
        run: |
          echo "ðŸ‘‰ Start MARIADB"
          SQL_FILE=$(find . -name "f1db-sql-mysql-single-inserts.sql")
          echo "Find SQL file: $SQL_FILE"
          pv "$SQL_FILE" | mariadb --skip-ssl \
            -h $DB_HOST \
            -u $DB_USER \
            -p"$DB_PASSWORD" \
            $DB_NAME
          echo "âœ… Exit Execution MARIADB"
      - name: Update last-release.txt
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          echo "${{ steps.get_latest_release.outputs.latest_tag }}" > db/last-release.txt
          echo "Updated last-release.txt with new version"
      - name: Get previous tag
        id: previousTag
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            PREVIOUS_TAG=$(git describe --tags --abbrev=0)
          else
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "previousTag=$PREVIOUS_TAG" >> "$GITHUB_OUTPUT"
          echo "Previous tag: $PREVIOUS_TAG"
      - name: Update package.json version with yarn
        id: update_version
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          yarn version --patch --no-git-tag-version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=v$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "New version: v$NEW_VERSION"
      - name: Commit changes (without tag)
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          git add db/last-release.txt package.json
          git commit -m "chore(release): ${{ steps.update_version.outputs.new_version }}"
          git push origin main
          echo "âœ… Changes committed and pushed"
      - name: Create and push tag
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          git tag ${{ steps.update_version.outputs.new_version }}
          git push origin ${{ steps.update_version.outputs.new_version }}
          echo "âœ… Tag created and pushed"
      - name: Fetch all to sync local repo with remote
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          git fetch --all --tags --prune
          git pull origin main --rebase
          echo "âœ… Repository synced with remote"
      - name: Debug - Show git history
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          echo "ðŸ“Š Previous tag: ${{ steps.previousTag.outputs.previousTag }}"
          echo "ðŸ“Š New tag: ${{ steps.update_version.outputs.new_version }}"
          echo ""
          echo "ðŸ“Š All tags:"
          git tag -l
          echo ""
          echo "ðŸ“Š Commits between tags:"
          git log ${{ steps.previousTag.outputs.previousTag }}..${{ steps.update_version.outputs.new_version }} --oneline || echo "No commits found"
          echo ""
          echo "ðŸ“Š Tag details:"
          git show ${{ steps.previousTag.outputs.previousTag }} --no-patch
          git show ${{ steps.update_version.outputs.new_version }} --no-patch
      - name: Generate CHANGELOG
        id: changelog
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          # Ottieni i commit tra i due tag
          COMMITS=$(git log ${{ steps.previousTag.outputs.previousTag }}..${{ steps.update_version.outputs.new_version }} --pretty=format:"- %s (%h)" --no-merges)
          
          # Crea l'entry del changelog
          CHANGELOG_ENTRY="## ${{ steps.update_version.outputs.new_version }} ($(date +%Y-%m-%d))

          ### Database Update
          - Updated F1DB to \`${{ steps.get_latest_release.outputs.latest_tag }}\`
          
          ### Changes
          $COMMITS
          "
          
          # Prepend al CHANGELOG esistente
          if [ -f "CHANGELOG.md" ]; then
            echo "$CHANGELOG_ENTRY" | cat - CHANGELOG.md > CHANGELOG.tmp
            mv CHANGELOG.tmp CHANGELOG.md
          else
            echo "$CHANGELOG_ENTRY" > CHANGELOG.md
          fi
          
          echo "âœ… CHANGELOG generated"
          
          # Set output for release notes
          {
            echo "changes<<EOF"
            echo "$CHANGELOG_ENTRY"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
      - name: Commit CHANGELOG
        if: steps.check_release.outputs.is_new_release == 'true'
        run: |
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG for ${{ steps.update_version.outputs.new_version }}"
          git push origin main
          echo "âœ… CHANGELOG committed and pushed"
      - name: Create Release
        if: steps.check_release.outputs.is_new_release == 'true'
        uses: ncipollo/release-action@v1
        with:
          allowUpdates: true
          draft: false
          makeLatest: true
          name: ${{ steps.update_version.outputs.new_version }}
          body: ${{ steps.changelog.outputs.changes }}
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ steps.update_version.outputs.new_version }}
